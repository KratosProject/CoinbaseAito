"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matchFilter = void 0;
// === Obtain O(1) filter function from query
/**
 * > This is an advanced function of grammY.
 *
 * Takes a filter query and turns it into a predicate function that can check in
 * constant time whether a given context object satisfies the query. The created
 * predicate can be passed to `bot.filter` and will narrow down the context
 * accordingly.
 *
 * This function is used internally by `bot.on` but exposed for advanced usage
 * like the following.
 * ```ts
 * // Listens for all messages and channel posts except forwards
 * `bot.drop(matchFilter(':forward_date'), ctx => { ... })
 * ```
 *
 * Check out the
 * [documentation](https://doc.deno.land/https/deno.land/x/grammy/mod.ts#Composer)
 * of `bot.on` for examples. In addition, the
 * [website](https://grammy.dev/guide/filter-queries.html) contains more
 * information about how filter queries work in grammY.
 *
 * @param filter A filter query or an array of filter queries
 */
function matchFilter(filter) {
    if (Array.isArray(filter)) {
        // Must annotate with less strict types to accelerate compilation
        // deno-lint-ignore ban-types
        const toPred = matchSingleFilter;
        const predicates = filter.map(toPred);
        return (ctx) => predicates.some(pred => pred(ctx));
    }
    else {
        const pred = matchSingleFilter(filter);
        return (ctx) => pred(ctx);
    }
}
exports.matchFilter = matchFilter;
function matchSingleFilter(filter) {
    const [l1, l2, l3] = filter.split(':');
    // check L1 syntax
    if (l1 === undefined)
        throw new Error('Empty filter query given');
    if (!((l2 !== undefined && l1 === '') || l1 in UPDATE_KEYS)) {
        const permitted = Object.keys(UPDATE_KEYS);
        throw new Error(`Invalid L1 filter '${l1}' given in '${filter}'. Permitted values are: ${permitted
            .map(k => `'${k}'`)
            .join(', ')}`);
    }
    // pick L1 object selector function
    const l1Obj = l1 === ''
        ? ctx => {
            const elem = L1_DEFAULTS.find(p => p in ctx.update);
            if (elem === undefined)
                return undefined;
            return ctx.update[elem];
        }
        : ctx => ctx.update[l1];
    // immediately return if L2 is not given
    if (l2 === undefined)
        return (ctx) => l1Obj(ctx) !== undefined;
    // check L2 syntax
    const l1ValidationObjs = l1 === ''
        ? L1_DEFAULTS.reduce((agg, p) => ({ ...agg, ...UPDATE_KEYS[p] }), {})
        : UPDATE_KEYS[l1];
    if (!((l3 !== undefined && l2 === '') || l2 in l1ValidationObjs)) {
        const permitted = Object.keys(l1ValidationObjs);
        throw new Error(`Invalid L2 filter '${l2}' given in '${filter}'. Permitted values are: ${permitted
            .map(k => `'${k}'`)
            .join(', ')}`);
    }
    // pick L2 object selector function
    const l2Obj = l2 === ''
        ? ctx => {
            const l1o = l1Obj(ctx);
            if (l1o === undefined)
                return undefined;
            const elem = L2_DEFAULTS.find(p => p in l1o);
            if (elem === undefined)
                return undefined;
            return l1o[elem];
        }
        : ctx => {
            const l1o = l1Obj(ctx);
            return l1o === undefined ? undefined : l1o[l2];
        };
    // immediately return if L3 is not given
    if (l3 === undefined)
        return (ctx) => l2Obj(ctx) !== undefined;
    // check L3 syntax
    const l2ValidationObjs = l2 === ''
        ? L2_DEFAULTS.reduce((agg, p) => ({ ...agg, ...l1ValidationObjs[p] }), {})
        : l1ValidationObjs[l2];
    if (!(l3 in l2ValidationObjs)) {
        const permitted = Object.keys(l2ValidationObjs);
        if (permitted.length === 0)
            throw new Error(`Invalid L3 filter '${l3}' given in '${filter}'. No further filtering is possible after '${l1}:${l2}'.`);
        else
            throw new Error(`Invalid L3 filter '${l3}' given in '${filter}'. Permitted values are: ${permitted
                .map(k => `'${k}'`)
                .join(', ')}`);
    }
    // final filtering function for L3 filter
    return l3 === 'me' // special handling for `me` shortcut
        ? (ctx) => {
            const me = ctx.me.id;
            return testMaybeArray(l2Obj(ctx), u => u.id === me);
        }
        : (ctx) => testMaybeArray(l2Obj(ctx), e => e[l3] || e.type === l3);
}
function testMaybeArray(t, pred) {
    const p = (x) => !!x && pred(x);
    return Array.isArray(t) ? t.some(p) : p(t);
}
// === Define a structure to validate the queries
const ENTITY_KEYS = {
    mention: {},
    hashtag: {},
    cashtag: {},
    bot_command: {},
    url: {},
    email: {},
    phone_number: {},
    bold: {},
    italic: {},
    underline: {},
    strikethrough: {},
    code: {},
};
const USER_KEYS = {
    me: {},
    is_bot: {},
};
const MESSAGE_KEYS = {
    text: {},
    animation: {},
    audio: {},
    document: {},
    photo: {},
    sticker: {},
    video: {},
    video_note: {},
    voice: {},
    contact: {},
    dice: {},
    game: {},
    poll: {},
    venue: {},
    location: {},
    new_chat_members: USER_KEYS,
    left_chat_member: USER_KEYS,
    new_chat_title: {},
    new_chat_photo: {},
    delete_chat_photo: {},
    group_chat_created: {},
    supergroup_chat_created: {},
    channel_chat_created: {},
    message_auto_delete_timer_changed: {},
    migrate_to_chat_id: {},
    migrate_from_chat_id: {},
    pinned_message: {},
    invoice: {},
    successful_payment: {},
    connected_website: {},
    passport_data: {},
    proximity_alert_triggered: {},
    voice_chat_scheduled: {},
    voice_chat_started: {},
    voice_chat_ended: {},
    voice_chat_participants_invited: {},
    entities: ENTITY_KEYS,
    caption_entities: ENTITY_KEYS,
    forward_date: {},
    caption: {},
};
const CALLBACK_QUERY_KEYS = { data: {}, game_short_name: {} };
const CHAT_MEMBER_UPDATED_KEYS = {
    chat: {},
    from: USER_KEYS,
    old_chat_member: {},
    new_chat_member: {},
};
const UPDATE_KEYS = {
    message: MESSAGE_KEYS,
    edited_message: MESSAGE_KEYS,
    channel_post: MESSAGE_KEYS,
    edited_channel_post: MESSAGE_KEYS,
    inline_query: {},
    chosen_inline_result: {},
    callback_query: CALLBACK_QUERY_KEYS,
    shipping_query: {},
    pre_checkout_query: {},
    poll: {},
    poll_answer: {},
    my_chat_member: CHAT_MEMBER_UPDATED_KEYS,
    chat_member: CHAT_MEMBER_UPDATED_KEYS,
};
// === Define some helpers for handling default values, e.g. in '::url'
const L1_DEFAULTS = ['message', 'channel_post'];
const L2_DEFAULTS = ['entities', 'caption_entities'];
