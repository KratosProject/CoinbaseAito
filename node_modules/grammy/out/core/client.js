"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRawApi = void 0;
const node_fetch_1 = require("node-fetch");
const platform_1 = require("../platform");
const error_1 = require("./error");
const payload_1 = require("./payload");
const debug = platform_1.debug('grammy:core');
// Transformer base functions
const concatTransformer = (prev, trans) => (method, payload, signal) => trans(prev, method, payload, signal);
const DEFAULT_OPTIONS = {
    apiRoot: 'https://api.telegram.org',
    buildUrl: (root, token, method) => `${root}/bot${token}/${method}`,
    baseFetchConfig: platform_1.baseFetchConfig,
    canUseWebhookReply: () => false,
};
class ApiClient {
    constructor(token, options, webhookReplyEnvelope = {}) {
        this.token = token;
        this.webhookReplyEnvelope = webhookReplyEnvelope;
        this.hasUsedWebhookReply = false;
        this.installedTransformers = [];
        this.call = async (method, payload, signal) => {
            debug('Calling', method);
            const url = this.options.buildUrl(this.options.apiRoot, this.token, method);
            const transformed = payload_1.transformPayload(method, payload !== null && payload !== void 0 ? payload : {});
            const config = payload_1.requiresFormDataUpload(transformed)
                ? payload_1.createFormDataPayload(transformed)
                : payload_1.createJsonPayload(transformed);
            if (this.webhookReplyEnvelope.send !== undefined &&
                !this.hasUsedWebhookReply &&
                typeof config.body === 'string' &&
                this.options.canUseWebhookReply(method)) {
                this.hasUsedWebhookReply = true;
                await this.webhookReplyEnvelope.send(config.body);
                return { ok: true, result: true };
            }
            else {
                const res = await node_fetch_1.default(url, {
                    ...this.options.baseFetchConfig,
                    signal,
                    ...config,
                });
                return await res.json();
            }
        };
        this.options = { ...DEFAULT_OPTIONS, ...options };
    }
    use(...transformers) {
        this.call = transformers.reduce(concatTransformer, this.call);
        this.installedTransformers.push(...transformers);
        return this;
    }
    async callApi(method, payload, signal) {
        const data = await this.call(method, payload, signal);
        if (data.ok)
            return data.result;
        else
            throw new error_1.GrammyError(`Call to ${method} failed!`, data, payload);
    }
}
/**
 * Creates a new transformable API, i.e. an object that lets you perform raw API
 * calls to the Telegram Bot API server but pass the calls through a stack of
 * transformers before. This will create a new API client instance under the
 * hood that will be used to connect to the Telegram servers. You therefore need
 * to pass the bot token. In addition, you may pass API client options as well
 * as a webhook reply envelope that allows the client to perform up to one HTTP
 * request in response to a webhook call if this is desired.
 *
 * @param token The bot's token
 * @param options A number of options to pass to the created API client
 * @param webhookReplyEnvelope The webhook reply envelope that will be used
 */
function createRawApi(token, options, webhookReplyEnvelope) {
    const client = new ApiClient(token, options, webhookReplyEnvelope);
    const proxyHandler = {
        get(_, m) {
            return client.callApi.bind(client, m);
        },
        ...proxyMethods,
    };
    const raw = new Proxy({}, proxyHandler);
    const installedTransformers = client.installedTransformers;
    const api = {
        raw,
        installedTransformers,
        use: (...t) => {
            client.use(...t);
            return api;
        },
    };
    return api;
}
exports.createRawApi = createRawApi;
const proxyMethods = {
    set() {
        return false;
    },
    defineProperty() {
        return false;
    },
    deleteProperty() {
        return false;
    },
    ownKeys() {
        return [];
    },
};
