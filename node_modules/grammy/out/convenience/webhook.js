"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.webhookCallback = void 0;
const platform_1 = require("../platform");
const debugErr = platform_1.debug('grammy:error');
const standard = (req, res) => ({
    update: req.body,
    respond: json => res.send(json),
});
const withCtx = ctx => ({
    update: ctx.req.body,
    respond: json => (ctx.response.body = json),
});
const frameworkAdapters = {
    express: standard,
    http: standard,
    https: standard,
    koa: withCtx,
    oak: withCtx,
    fastify: standard,
};
/**
 * Creates a callback function that you can pass to a web framework (such as
 * express) if you want to run your bot via webhooks. Use it like this:
 * ```ts
 * const app = express() // or whatever you're using
 * const bot = new Bot('<token>')
 *
 * app.use(webhookCallback(bot, 'express'))
 * ```
 *
 * Confer the grammY
 * [documentation](https://grammy.dev/guide/deployment-types.html) to read more
 * about how to run your bot with webhooks.
 *
 * @param bot The bot for which to create a callback
 * @param framework An optional string identifying the framework (default:
 * 'express')
 * @param onTimeout An optional strategy to handle timeouts (default: 'throw')
 * @param timeoutMilliseconds An optional number of timeout milliseconds
 * (default: 10_000)
 */
function webhookCallback(bot, framework = 'express', onTimeout = 'throw', timeoutMilliseconds = 10000) {
    var _a;
    const server = (_a = frameworkAdapters[framework]) !== null && _a !== void 0 ? _a : standard;
    let firstUpdate = true;
    let initialized = false;
    let initCall;
    return async (...args) => {
        const { update, respond } = server(...args);
        const webhookReplyEnvelope = {
            send: async (json) => {
                await respond(json);
            },
        };
        if (!initialized) {
            if (firstUpdate) {
                initCall = bot.init();
                firstUpdate = false;
            }
            await initCall;
            initialized = true;
        }
        await timeoutIfNecessary(bot.handleUpdate(update, webhookReplyEnvelope), typeof onTimeout === 'function'
            ? () => onTimeout(...args)
            : onTimeout, timeoutMilliseconds);
    };
}
exports.webhookCallback = webhookCallback;
function timeoutIfNecessary(task, onTimeout, timeout) {
    if (timeout === Infinity)
        return task;
    return new Promise((resolve, reject) => {
        const handle = setTimeout(() => {
            if (onTimeout === 'throw') {
                reject(new Error(`Request timed out after ${timeout} ms`));
            }
            else {
                if (typeof onTimeout === 'function')
                    onTimeout();
                resolve();
            }
            const now = Date.now();
            task.finally(() => {
                const diff = Date.now() - now;
                debugErr(`Request completed ${diff} ms after timeout!`);
            });
        }, timeout);
        task.then(resolve)
            .catch(reject)
            .finally(() => clearTimeout(handle));
    });
}
