import { AliasProps, Context } from './context';
import { Update } from './platform';
declare type FilterFunction<C extends Context, D extends C> = (ctx: C) => ctx is D;
/**
 * > This is an advanced function of grammY.
 *
 * Takes a filter query and turns it into a predicate function that can check in
 * constant time whether a given context object satisfies the query. The created
 * predicate can be passed to `bot.filter` and will narrow down the context
 * accordingly.
 *
 * This function is used internally by `bot.on` but exposed for advanced usage
 * like the following.
 * ```ts
 * // Listens for all messages and channel posts except forwards
 * `bot.drop(matchFilter(':forward_date'), ctx => { ... })
 * ```
 *
 * Check out the
 * [documentation](https://doc.deno.land/https/deno.land/x/grammy/mod.ts#Composer)
 * of `bot.on` for examples. In addition, the
 * [website](https://grammy.dev/guide/filter-queries.html) contains more
 * information about how filter queries work in grammY.
 *
 * @param filter A filter query or an array of filter queries
 */
export declare function matchFilter<C extends Context, Q extends FilterQuery>(filter: Q | Q[]): FilterFunction<C, Filter<C, Q>>;
declare const UPDATE_KEYS: {
    readonly message: {
        readonly text: {};
        readonly animation: {};
        readonly audio: {};
        readonly document: {};
        readonly photo: {};
        readonly sticker: {};
        readonly video: {};
        readonly video_note: {};
        readonly voice: {};
        readonly contact: {};
        readonly dice: {};
        readonly game: {};
        readonly poll: {};
        readonly venue: {};
        readonly location: {};
        readonly new_chat_members: {
            readonly me: {};
            readonly is_bot: {};
        };
        readonly left_chat_member: {
            readonly me: {};
            readonly is_bot: {};
        };
        readonly new_chat_title: {};
        readonly new_chat_photo: {};
        readonly delete_chat_photo: {};
        readonly group_chat_created: {};
        readonly supergroup_chat_created: {};
        readonly channel_chat_created: {};
        readonly message_auto_delete_timer_changed: {};
        readonly migrate_to_chat_id: {};
        readonly migrate_from_chat_id: {};
        readonly pinned_message: {};
        readonly invoice: {};
        readonly successful_payment: {};
        readonly connected_website: {};
        readonly passport_data: {};
        readonly proximity_alert_triggered: {};
        readonly voice_chat_scheduled: {};
        readonly voice_chat_started: {};
        readonly voice_chat_ended: {};
        readonly voice_chat_participants_invited: {};
        readonly entities: {
            readonly mention: {};
            readonly hashtag: {};
            readonly cashtag: {};
            readonly bot_command: {};
            readonly url: {};
            readonly email: {};
            readonly phone_number: {};
            readonly bold: {};
            readonly italic: {};
            readonly underline: {};
            readonly strikethrough: {};
            readonly code: {};
        };
        readonly caption_entities: {
            readonly mention: {};
            readonly hashtag: {};
            readonly cashtag: {};
            readonly bot_command: {};
            readonly url: {};
            readonly email: {};
            readonly phone_number: {};
            readonly bold: {};
            readonly italic: {};
            readonly underline: {};
            readonly strikethrough: {};
            readonly code: {};
        };
        readonly forward_date: {};
        readonly caption: {};
    };
    readonly edited_message: {
        readonly text: {};
        readonly animation: {};
        readonly audio: {};
        readonly document: {};
        readonly photo: {};
        readonly sticker: {};
        readonly video: {};
        readonly video_note: {};
        readonly voice: {};
        readonly contact: {};
        readonly dice: {};
        readonly game: {};
        readonly poll: {};
        readonly venue: {};
        readonly location: {};
        readonly new_chat_members: {
            readonly me: {};
            readonly is_bot: {};
        };
        readonly left_chat_member: {
            readonly me: {};
            readonly is_bot: {};
        };
        readonly new_chat_title: {};
        readonly new_chat_photo: {};
        readonly delete_chat_photo: {};
        readonly group_chat_created: {};
        readonly supergroup_chat_created: {};
        readonly channel_chat_created: {};
        readonly message_auto_delete_timer_changed: {};
        readonly migrate_to_chat_id: {};
        readonly migrate_from_chat_id: {};
        readonly pinned_message: {};
        readonly invoice: {};
        readonly successful_payment: {};
        readonly connected_website: {};
        readonly passport_data: {};
        readonly proximity_alert_triggered: {};
        readonly voice_chat_scheduled: {};
        readonly voice_chat_started: {};
        readonly voice_chat_ended: {};
        readonly voice_chat_participants_invited: {};
        readonly entities: {
            readonly mention: {};
            readonly hashtag: {};
            readonly cashtag: {};
            readonly bot_command: {};
            readonly url: {};
            readonly email: {};
            readonly phone_number: {};
            readonly bold: {};
            readonly italic: {};
            readonly underline: {};
            readonly strikethrough: {};
            readonly code: {};
        };
        readonly caption_entities: {
            readonly mention: {};
            readonly hashtag: {};
            readonly cashtag: {};
            readonly bot_command: {};
            readonly url: {};
            readonly email: {};
            readonly phone_number: {};
            readonly bold: {};
            readonly italic: {};
            readonly underline: {};
            readonly strikethrough: {};
            readonly code: {};
        };
        readonly forward_date: {};
        readonly caption: {};
    };
    readonly channel_post: {
        readonly text: {};
        readonly animation: {};
        readonly audio: {};
        readonly document: {};
        readonly photo: {};
        readonly sticker: {};
        readonly video: {};
        readonly video_note: {};
        readonly voice: {};
        readonly contact: {};
        readonly dice: {};
        readonly game: {};
        readonly poll: {};
        readonly venue: {};
        readonly location: {};
        readonly new_chat_members: {
            readonly me: {};
            readonly is_bot: {};
        };
        readonly left_chat_member: {
            readonly me: {};
            readonly is_bot: {};
        };
        readonly new_chat_title: {};
        readonly new_chat_photo: {};
        readonly delete_chat_photo: {};
        readonly group_chat_created: {};
        readonly supergroup_chat_created: {};
        readonly channel_chat_created: {};
        readonly message_auto_delete_timer_changed: {};
        readonly migrate_to_chat_id: {};
        readonly migrate_from_chat_id: {};
        readonly pinned_message: {};
        readonly invoice: {};
        readonly successful_payment: {};
        readonly connected_website: {};
        readonly passport_data: {};
        readonly proximity_alert_triggered: {};
        readonly voice_chat_scheduled: {};
        readonly voice_chat_started: {};
        readonly voice_chat_ended: {};
        readonly voice_chat_participants_invited: {};
        readonly entities: {
            readonly mention: {};
            readonly hashtag: {};
            readonly cashtag: {};
            readonly bot_command: {};
            readonly url: {};
            readonly email: {};
            readonly phone_number: {};
            readonly bold: {};
            readonly italic: {};
            readonly underline: {};
            readonly strikethrough: {};
            readonly code: {};
        };
        readonly caption_entities: {
            readonly mention: {};
            readonly hashtag: {};
            readonly cashtag: {};
            readonly bot_command: {};
            readonly url: {};
            readonly email: {};
            readonly phone_number: {};
            readonly bold: {};
            readonly italic: {};
            readonly underline: {};
            readonly strikethrough: {};
            readonly code: {};
        };
        readonly forward_date: {};
        readonly caption: {};
    };
    readonly edited_channel_post: {
        readonly text: {};
        readonly animation: {};
        readonly audio: {};
        readonly document: {};
        readonly photo: {};
        readonly sticker: {};
        readonly video: {};
        readonly video_note: {};
        readonly voice: {};
        readonly contact: {};
        readonly dice: {};
        readonly game: {};
        readonly poll: {};
        readonly venue: {};
        readonly location: {};
        readonly new_chat_members: {
            readonly me: {};
            readonly is_bot: {};
        };
        readonly left_chat_member: {
            readonly me: {};
            readonly is_bot: {};
        };
        readonly new_chat_title: {};
        readonly new_chat_photo: {};
        readonly delete_chat_photo: {};
        readonly group_chat_created: {};
        readonly supergroup_chat_created: {};
        readonly channel_chat_created: {};
        readonly message_auto_delete_timer_changed: {};
        readonly migrate_to_chat_id: {};
        readonly migrate_from_chat_id: {};
        readonly pinned_message: {};
        readonly invoice: {};
        readonly successful_payment: {};
        readonly connected_website: {};
        readonly passport_data: {};
        readonly proximity_alert_triggered: {};
        readonly voice_chat_scheduled: {};
        readonly voice_chat_started: {};
        readonly voice_chat_ended: {};
        readonly voice_chat_participants_invited: {};
        readonly entities: {
            readonly mention: {};
            readonly hashtag: {};
            readonly cashtag: {};
            readonly bot_command: {};
            readonly url: {};
            readonly email: {};
            readonly phone_number: {};
            readonly bold: {};
            readonly italic: {};
            readonly underline: {};
            readonly strikethrough: {};
            readonly code: {};
        };
        readonly caption_entities: {
            readonly mention: {};
            readonly hashtag: {};
            readonly cashtag: {};
            readonly bot_command: {};
            readonly url: {};
            readonly email: {};
            readonly phone_number: {};
            readonly bold: {};
            readonly italic: {};
            readonly underline: {};
            readonly strikethrough: {};
            readonly code: {};
        };
        readonly forward_date: {};
        readonly caption: {};
    };
    readonly inline_query: {};
    readonly chosen_inline_result: {};
    readonly callback_query: {
        readonly data: {};
        readonly game_short_name: {};
    };
    readonly shipping_query: {};
    readonly pre_checkout_query: {};
    readonly poll: {};
    readonly poll_answer: {};
    readonly my_chat_member: {
        readonly chat: {};
        readonly from: {
            readonly me: {};
            readonly is_bot: {};
        };
        readonly old_chat_member: {};
        readonly new_chat_member: {};
    };
    readonly chat_member: {
        readonly chat: {};
        readonly from: {
            readonly me: {};
            readonly is_bot: {};
        };
        readonly old_chat_member: {};
        readonly new_chat_member: {};
    };
};
declare type KeyOf<T> = string & keyof T;
declare type S = typeof UPDATE_KEYS;
declare type L1 = KeyOf<S>;
declare type L2<K extends L1 = L1> = K extends unknown ? `${K}:${KeyOf<S[K]>}` : never;
declare type L3<K0 extends L1 = L1> = K0 extends unknown ? L3_<K0> : never;
declare type L3_<K0 extends L1, K1 extends KeyOf<S[K0]> = KeyOf<S[K0]>> = K1 extends unknown ? `${K0}:${K1}:${KeyOf<S[K0][K1]>}` : never;
declare type L123 = L1 | L2 | L3;
declare type PermitL2Defaults<Q extends string = L123> = Q extends `${infer R}:${L2Defaults}:${infer S}` ? Q | `${R}::${S}` : Q;
declare type PermitL1Defaults<Q extends string = PermitL2Defaults> = Q extends `${L1Defaults}:${infer R}` ? Q | `:${R}` : Q;
declare type AllValidFilterQueries = PermitL1Defaults;
/**
 * Represents a filter query that can be passed to `bot.on`. There are three
 * different kinds of filter queries: Level 1, Level 2, and Level 3. Check out
 * the [website](https://grammy.dev/guide/filter-queries.html) to read about how
 * filter queries work in grammY, and how to use them.
 *
 * Here are three brief examples:
 * ```ts
 * // Listen for messages of any type (Level 1)
 * bot.on('message', ctx => { ... })
 * // Listen for audio messages only (Level 2)
 * bot.on('message:audio', ctx => { ... })
 * // Listen for text messages that have a URL entity (Level 3)
 * bot.on('message:entities:url', ctx => { ... })
 * ```
 */
export declare type FilterQuery = AllValidFilterQueries;
/**
 * Any kind of value that appears in the Telegram Bot API. When intersected with
 * an optional field, it effectively removes `| undefined`.
 */
declare type SomeObject = object;
declare type NotUndefined = string | number | boolean | SomeObject;
/**
 * Given a FilterQuery, returns an object that, when intersected with an Update,
 * marks those properties as required that are guaranteed to exist.
 */
declare type RunQuery<Q extends string> = L1Combinations<Q, L1Parts<Q>>;
declare type L1Combinations<Q extends string, L1 extends string> = Combine<L1Fields<Q, L1>, L1>;
declare type L1Fields<Q extends string, L1 extends string> = L1 extends unknown ? Record<L1, L2Combinations<L2Parts<Q, L1>>> : never;
declare type L2Combinations<L2 extends string> = [L2] extends [never] ? NotUndefined : Combine<L2Fields<L2>, L2>;
declare type L2Fields<L2 extends string> = L2 extends unknown ? Record<L2 | Twins<L2>, NotUndefined> : never;
declare type Combine<U, K extends string> = U extends unknown ? U & Partial<Record<Exclude<K, keyof U>, undefined>> : never;
declare type L1Parts<Q extends string> = Q extends `${infer U}:${string}` ? U : Q;
declare type L2Parts<Q extends string, P extends string> = Q extends `${P}:${infer U}:${string}` ? U : Q extends `${P}:${infer U}` ? U : never;
/**
 * This type infers which properties will be present on the given context object
 * provided it matches given filter query. If the filter query is a union type,
 * the produced context object will be a union of possible combinations, hence
 * allowing you to narrow down manually which of the properties are present.
 *
 * In some sense, this type computes `matchFilter` on the type level.
 */
export declare type Filter<C extends Context, Q extends FilterQuery> = PerformQuery<C, RunQuery<FillDefaults<Q>>>;
declare type PerformQuery<C extends Context, U extends SomeObject> = U extends unknown ? FilteredContext<C, Update & U> : never;
declare type FilteredContext<C extends Context, U extends Update> = C & Record<'update', U> & AliasProps<Omit<U, 'update_id'>> & Shortcuts<U>;
interface Shortcuts<U extends Update> {
    msg: [U['callback_query']] extends [SomeObject] ? unknown : [U['message']] extends [SomeObject] ? U['message'] : [U['edited_message']] extends [SomeObject] ? U['edited_message'] : [U['channel_post']] extends [SomeObject] ? U['channel_post'] : [U['edited_channel_post']] extends [SomeObject] ? U['edited_channel_post'] : undefined;
    chat: Shortcuts<U>['msg'];
    from: [U['callback_query']] extends [SomeObject] ? U['callback_query'] : [U['inline_query']] extends [SomeObject] ? U['inline_query'] : [U['shipping_query']] extends [SomeObject] ? U['shipping_query'] : [U['pre_checkout_query']] extends [SomeObject] ? U['pre_checkout_query'] : [U['chosen_inline_result']] extends [SomeObject] ? U['chosen_inline_result'] : [U['message']] extends [SomeObject] ? U['message'] : [U['edited_message']] extends [SomeObject] ? U['edited_message'] : undefined;
}
declare const L1_DEFAULTS: readonly ["message", "channel_post"];
declare const L2_DEFAULTS: readonly ["entities", "caption_entities"];
declare type L1Defaults = typeof L1_DEFAULTS[number];
declare type L2Defaults = typeof L2_DEFAULTS[number];
declare type FillDefaults<Q extends string> = FillL1Default<FillL2Default<Q>>;
declare type FillL1Default<Q extends string> = Q extends `:${infer R}` ? `${L1Defaults}:${R}` : Q;
declare type FillL2Default<Q extends string> = Q extends `${infer U}::${infer V}` ? `${U}:${L2Defaults}:${V}` : Q;
declare type Twins<V extends string> = V extends KeyOf<Equivalents> ? Equivalents[V] : V;
declare type Equivalents = {
    entities: TextMessages;
    caption: CaptionMessages;
    caption_entities: CaptionMessages;
};
declare type TextMessages = 'text';
declare type CaptionMessages = 'animation' | 'audio' | 'document' | 'photo' | 'video' | 'voice';
export {};
